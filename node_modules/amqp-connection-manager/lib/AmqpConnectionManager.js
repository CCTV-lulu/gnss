// Generated by CoffeeScript 1.10.0
(function() {
  var AmqpConnectionManager, ChannelWrapper, EventEmitter, HEARTBEAT_IN_SECONDS, _, amqp, pb, urlUtils, wait,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  amqp = require('amqplib');

  urlUtils = require('url');

  _ = require('lodash');

  ChannelWrapper = require('./ChannelWrapper');

  wait = require('./helpers').wait;

  pb = require('promise-breaker');

  HEARTBEAT_IN_SECONDS = 5;

  AmqpConnectionManager = (function(superClass) {
    extend(AmqpConnectionManager, superClass);

    function AmqpConnectionManager(urls, options) {
      var ref, ref1, ref2;
      if (options == null) {
        options = {};
      }
      if (!urls && !options.findServers) {
        throw new Error("Must supply either `urls` or `findServers`");
      }
      this._channels = [];
      this._currentUrl = 0;
      this.connectionOptions = options.connectionOptions;
      this.heartbeatIntervalInSeconds = (ref = options.heartbeatIntervalInSeconds) != null ? ref : HEARTBEAT_IN_SECONDS;
      this.reconnectTimeInSeconds = (ref1 = options.reconnectTimeInSeconds) != null ? ref1 : this.heartbeatIntervalInSeconds;
      this.setMaxListeners(0);
      this._findServers = (ref2 = options.findServers) != null ? ref2 : (function() {
        return Promise.resolve(urls);
      });
      this._connect();
    }

    AmqpConnectionManager.prototype.createChannel = function(options) {
      var channel;
      if (options == null) {
        options = {};
      }
      channel = new ChannelWrapper(this, options);
      this._channels.push(channel);
      channel.once('close', (function(_this) {
        return function() {
          return _this._channels = _.without(_this._channels, channel);
        };
      })(this));
      return channel;
    };

    AmqpConnectionManager.prototype.close = function() {
      if (this._closed) {
        return;
      }
      this._closed = true;
      return Promise.all(this._channels.map(function(channel) {
        return channel.close();
      }))["catch"](function() {}).then((function(_this) {
        return function() {
          var ref;
          _this._channels = [];
          if ((ref = _this._currentConnection) != null) {
            ref.close();
          }
          return _this._currentConnection = null;
        };
      })(this));
    };

    AmqpConnectionManager.prototype.isConnected = function() {
      return this._currentConnection != null;
    };

    AmqpConnectionManager.prototype._connect = function() {
      if (this._closed || this._connecting || this.isConnected()) {
        return Promise.resolve();
      }
      this._connecting = true;
      return Promise.resolve().then((function(_this) {
        return function() {
          if (!_this._urls || (_this._currentUrl >= _this._urls.length)) {
            _this._currentUrl = 0;
            return pb.callFn(_this._findServers, 0, null);
          } else {
            return _this._urls;
          }
        };
      })(this)).then((function(_this) {
        return function(urls) {
          var amqpUrl, url;
          if ((urls != null) && !_.isArray(urls)) {
            urls = [urls];
          }
          _this._urls = urls;
          if (!urls || urls.length === 0) {
            throw new Error('amqp-connection-manager: No servers found');
          }
          url = urls[_this._currentUrl];
          _this._currentUrl++;
          amqpUrl = urlUtils.parse(url);
          if (amqpUrl.search != null) {
            amqpUrl.search += "&heartbeat=" + _this.heartbeatIntervalInSeconds;
          } else {
            amqpUrl.search = "?heartbeat=" + _this.heartbeatIntervalInSeconds;
          }
          return amqp.connect(urlUtils.format(amqpUrl), _this.connectionOptions).then(function(connection) {
            _this._currentConnection = connection;
            connection.on('error', function(err) {
              return Promise.resolve().then(function() {
                return this._currentConnection.close();
              })["catch"](function(err) {}).then(function() {
                _this._currentConnection = null;
                _this.emit('disconnect', {
                  err: err
                });
                return _this._connect();
              })["catch"](function(err) {

                /* !pragma coverage-skip-block */
                return console.error("amqp-connection-manager: AmqpConnectionManager:_connect()" + " - How did you get here?", err.stack);
              });
            });
            connection.on('close', function() {
              _this._currentConnection = null;
              return wait(_this.reconnectTimeInSeconds * 1000).then(function() {
                return _this._connect();
              });
            });
            _this._connecting = false;
            _this.emit('connect', {
              connection: connection,
              url: url
            });
            return null;
          });
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          _this.emit('disconnect', {
            err: err
          });
          _this._currentConnection = null;
          return wait(_this.reconnectTimeInSeconds * 1000).then(function() {
            _this._connecting = false;
            return _this._connect();
          });
        };
      })(this));
    };

    return AmqpConnectionManager;

  })(EventEmitter);

  module.exports = AmqpConnectionManager;

}).call(this);
